# Automated Failover and Disaster Recovery System

apiVersion: v1
kind: Namespace
metadata:
  name: failover-system
  labels:
    istio-injection: enabled

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: failover-controller
  namespace: failover-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: failover-controller
  template:
    metadata:
      labels:
        app: failover-controller
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
    spec:
      serviceAccountName: failover-controller
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - failover-controller
            topologyKey: kubernetes.io/hostname
      containers:
      - name: failover-controller
        image: quay.io/trustram/failover-controller:v4.4.0
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: RTO_TARGET_SECONDS
          value: "60"  # RTO < 1 minute
        - name: RPO_TARGET_SECONDS
          value: "5"   # RPO < 5 seconds
        - name: HEALTH_CHECK_INTERVAL
          value: "5"   # 5 seconds
        - name: FAILOVER_DECISION_THRESHOLD
          value: "3"   # 3 consecutive failures
        - name: PROMETHEUS_URL
          value: "http://prometheus.monitoring.svc.cluster.local:9090"
        - name: CLUSTER_REGISTRY_URL
          value: "http://cluster-manager.multi-cloud-system.svc.cluster.local:8080"
        resources:
          requests:
            cpu: 200m
            memory: 512Mi
          limits:
            cpu: 500m
            memory: 1Gi
        volumeMounts:
        - name: config
          mountPath: /etc/config
        - name: kubeconfigs
          mountPath: /etc/kubeconfigs
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: failover-config
      - name: kubeconfigs
        secret:
          secretName: cluster-kubeconfigs

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: failover-controller
  namespace: failover-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: failover-controller
rules:
- apiGroups: [""]
  resources: ["services", "endpoints", "pods", "nodes"]
  verbs: ["get", "list", "watch", "patch", "update"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets", "statefulsets"]
  verbs: ["get", "list", "watch", "patch", "update"]
- apiGroups: ["networking.istio.io"]
  resources: ["virtualservices", "destinationrules", "gateways"]
  verbs: ["get", "list", "watch", "create", "patch", "update", "delete"]
- apiGroups: ["networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch", "patch", "update"]
- apiGroups: ["cluster.x-k8s.io"]
  resources: ["clusters", "machines"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["failover.trustram.io"]
  resources: ["*"]
  verbs: ["*"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: failover-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: failover-controller
subjects:
- kind: ServiceAccount
  name: failover-controller
  namespace: failover-system

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: failover-config
  namespace: failover-system
data:
  config.yaml: |
    failover:
      rto_target: 60  # seconds
      rpo_target: 5   # seconds
      health_check_interval: 5  # seconds
      failover_threshold: 3      # consecutive failures
      recovery_threshold: 2      # consecutive successes
      
      decision_matrix:
        - condition: "service_health_check_failed"
          threshold: 3
          action: "activate_circuit_breaker"
          priority: 1
        
        - condition: "cluster_unreachable"
          threshold: 2
          action: "initiate_cluster_failover"
          priority: 2
        
        - condition: "high_error_rate"
          threshold: 0.05  # 5%
          action: "gradual_traffic_shift"
          priority: 3
        
        - condition: "high_latency"
          threshold: 1000  # ms
          action: "performance_based_routing"
          priority: 4
    
    health_checks:
      endpoints:
        - name: "api_health"
          url: "/health"
          method: "GET"
          timeout: 5
          expected_status: 200
          interval: 5
        
        - name: "database_health"
          url: "/health/database"
          method: "GET"
          timeout: 10
          expected_status: 200
          interval: 10
        
        - name: "external_dependencies"
          url: "/health/dependencies"
          method: "GET"
          timeout: 15
          expected_status: 200
          interval: 30
      
      cluster_checks:
        - name: "kubernetes_api"
          check_type: "api_server_health"
          timeout: 5
          interval: 10
        
        - name: "node_health"
          check_type: "node_ready_status"
          timeout: 5
          interval: 15
        
        - name: "etcd_health"
          check_type: "etcd_cluster_health"
          timeout: 10
          interval: 30
    
    disaster_recovery:
      strategies:
        - name: "hot_standby"
          rto: 60   # seconds
          rpo: 5    # seconds
          cost_multiplier: 2.0
          availability: 0.9999
          triggers:
            - "primary_cluster_failure"
            - "primary_region_failure"
        
        - name: "warm_standby"
          rto: 900  # 15 minutes
          rpo: 30   # seconds
          cost_multiplier: 1.3
          availability: 0.999
          triggers:
            - "extended_service_degradation"
            - "planned_maintenance"
        
        - name: "cold_standby"
          rto: 14400  # 4 hours
          rpo: 3600   # 1 hour
          cost_multiplier: 1.1
          availability: 0.99
          triggers:
            - "disaster_declaration"
            - "compliance_requirement"
    
    traffic_management:
      routing_policies:
        - name: "health_based_routing"
          enabled: true
          weight: 0.4
          conditions:
            - healthy_endpoints > 0
        
        - name: "latency_based_routing"
          enabled: true
          weight: 0.3
          conditions:
            - latency_p99 < 500  # ms
        
        - name: "error_rate_routing"
          enabled: true
          weight: 0.2
          conditions:
            - error_rate < 0.01  # 1%
        
        - name: "cost_based_routing"
          enabled: true
          weight: 0.1
          conditions:
            - cost_per_request < 0.005  # $0.005
      
      circuit_breaker:
        failure_threshold: 5
        timeout: 30  # seconds
        success_threshold: 3
        half_open_max_calls: 10
    
    data_replication:
      synchronous_replication:
        enabled: true
        max_lag: 5  # seconds
        consistency_level: "strong"
        target_clusters:
          - "aws-cluster"
          - "azure-cluster"
      
      asynchronous_replication:
        enabled: true
        max_lag: 30  # seconds
        consistency_level: "eventual"
        target_clusters:
          - "gcp-cluster"
      
      backup_strategy:
        frequency: "5m"  # every 5 minutes
        retention: "30d"
        encryption: true
        compression: true
        storage_locations:
          - "s3://trustram-backups-us-east-1"
          - "azure://trustrambackups/us-east"
          - "gs://trustram-backups-us-central1"
    
    monitoring:
      metrics:
        - name: "failover_time"
          type: "histogram"
          buckets: [1, 5, 10, 30, 60, 120, 300]
        
        - name: "recovery_time"
          type: "histogram"
          buckets: [1, 5, 10, 30, 60, 120, 300]
        
        - name: "data_loss"
          type: "counter"
          labels: ["cluster", "service"]
        
        - name: "circuit_breaker_state"
          type: "gauge"
          labels: ["service", "cluster"]
      
      alerts:
        - name: "rto_exceeded"
          condition: "failover_time > 60"
          severity: "critical"
        
        - name: "rpo_exceeded"
          condition: "data_loss > 5"
          severity: "critical"
        
        - name: "frequent_failovers"
          condition: "failover_count > 5 in 1h"
          severity: "warning"

---
# Custom Resource Definition for Failover Policies
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: failoverpolicies.failover.trustram.io
spec:
  group: failover.trustram.io
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              targets:
                type: array
                items:
                  type: object
                  properties:
                    name:
                      type: string
                    cluster:
                      type: string
                    priority:
                      type: integer
                    healthEndpoint:
                      type: string
              triggers:
                type: array
                items:
                  type: object
                  properties:
                    name:
                      type: string
                    condition:
                      type: string
                    threshold:
                      type: string
                    duration:
                      type: string
              actions:
                type: array
                items:
                  type: object
                  properties:
                    name:
                      type: string
                    type:
                      type: string
                    parameters:
                      type: object
              rto:
                type: integer
                minimum: 1
              rpo:
                type: integer
                minimum: 0
          status:
            type: object
            properties:
              activeTarget:
                type: string
              lastFailover:
                type: string
              currentRTO:
                type: integer
              currentRPO:
                type: integer
              healthStatus:
                type: object
  scope: Namespaced
  names:
    plural: failoverpolicies
    singular: failoverpolicy
    kind: FailoverPolicy
    shortNames:
    - fp

---
# Default Failover Policy for TrustStram API
apiVersion: failover.trustram.io/v1
kind: FailoverPolicy
metadata:
  name: trustram-api-failover
  namespace: trustram-system
spec:
  targets:
  - name: "aws-primary"
    cluster: "aws-cluster"
    priority: 1
    healthEndpoint: "https://api-aws.trustram.local/health"
  - name: "azure-secondary"
    cluster: "azure-cluster"
    priority: 2
    healthEndpoint: "https://api-azure.trustram.local/health"
  - name: "gcp-tertiary"
    cluster: "gcp-cluster"
    priority: 3
    healthEndpoint: "https://api-gcp.trustram.local/health"
  triggers:
  - name: "health_check_failure"
    condition: "http_status != 200"
    threshold: "3"
    duration: "15s"
  - name: "high_error_rate"
    condition: "error_rate > 0.05"
    threshold: "2m"
    duration: "5m"
  - name: "high_latency"
    condition: "latency_p99 > 1000"
    threshold: "1m"
    duration: "3m"
  actions:
  - name: "dns_failover"
    type: "dns_update"
    parameters:
      ttl: 60
      record_type: "A"
  - name: "traffic_shift"
    type: "istio_traffic_split"
    parameters:
      gradual: true
      step_percentage: 25
      step_interval: "30s"
  - name: "notification"
    type: "alert"
    parameters:
      channels: ["slack", "pagerduty", "email"]
  rto: 60  # seconds
  rpo: 5   # seconds

---
apiVersion: v1
kind: Service
metadata:
  name: failover-controller
  namespace: failover-system
  labels:
    app: failover-controller
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: metrics
    port: 9090
    targetPort: 9090
  selector:
    app: failover-controller