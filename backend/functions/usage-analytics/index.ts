// Ooumph Coin Usage Analytics Edge Function
// Provides comprehensive analytics and reporting for credit usage

Deno.serve(async (req) => {
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n        'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE, PATCH',\n        'Access-Control-Max-Age': '86400',\n        'Access-Control-Allow-Credentials': 'false'\n    };\n\n    if (req.method === 'OPTIONS') {\n        return new Response(null, { status: 200, headers: corsHeaders });\n    }\n\n    if (req.method !== 'POST') {\n        return new Response(\n            JSON.stringify({ error: { code: 'METHOD_NOT_ALLOWED', message: 'Only POST method is allowed' } }),\n            { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n    }\n\n    try {\n        const {\n            timeframe = '30d', // '7d', '30d', '90d', '1y'\n            reportType = 'summary', // 'summary', 'detailed', 'workflows', 'trends'\n            groupBy = 'day', // 'hour', 'day', 'week', 'month'\n            includeBreakdown = false,\n            workflowIds = null, // Filter by specific workflows\n            dateFrom = null,\n            dateTo = null\n        } = await req.json();\n\n        console.log('Usage analytics request:', { timeframe, reportType, groupBy });\n\n        // Get environment variables\n        const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\n        const supabaseUrl = Deno.env.get('SUPABASE_URL');\n\n        if (!serviceRoleKey || !supabaseUrl) {\n            throw new Error('Supabase configuration missing');\n        }\n\n        // Get user from auth header\n        const authHeader = req.headers.get('authorization');\n        if (!authHeader) {\n            throw new Error('Authorization header is required');\n        }\n\n        const token = authHeader.replace('Bearer ', '');\n        const userResponse = await fetch(`${supabaseUrl}/auth/v1/user`, {\n            headers: {\n                'Authorization': `Bearer ${token}`,\n                'apikey': serviceRoleKey\n            }\n        });\n\n        if (!userResponse.ok) {\n            throw new Error('Invalid or expired token');\n        }\n\n        const userData = await userResponse.json();\n        const userId = userData.id;\n\n        console.log('Analytics request for user:', userId);\n\n        // Calculate date range\n        let startDate, endDate;\n        \n        if (dateFrom && dateTo) {\n            startDate = new Date(dateFrom);\n            endDate = new Date(dateTo);\n        } else {\n            endDate = new Date();\n            startDate = new Date();\n            \n            switch (timeframe) {\n                case '7d':\n                    startDate.setDate(endDate.getDate() - 7);\n                    break;\n                case '30d':\n                    startDate.setDate(endDate.getDate() - 30);\n                    break;\n                case '90d':\n                    startDate.setDate(endDate.getDate() - 90);\n                    break;\n                case '1y':\n                    startDate.setFullYear(endDate.getFullYear() - 1);\n                    break;\n                default:\n                    startDate.setDate(endDate.getDate() - 30);\n            }\n        }\n\n        const startIso = startDate.toISOString();\n        const endIso = endDate.toISOString();\n\n        // Base query parameters\n        let baseQuery = `user_id=eq.${userId}&created_at=gte.${startIso}&created_at=lte.${endIso}`;\n        \n        if (workflowIds && Array.isArray(workflowIds) && workflowIds.length > 0) {\n            baseQuery += `&workflow_id=in.(${workflowIds.join(',')})`;\n        }\n\n        // Generate analytics based on report type\n        let analyticsData = {};\n\n        if (reportType === 'summary' || reportType === 'detailed') {\n            // Fetch usage data\n            const usageResponse = await fetch(\n                `${supabaseUrl}/rest/v1/usage_tracking?${baseQuery}&select=*&order=created_at.desc`,\n                {\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json'\n                    }\n                }\n            );\n\n            if (!usageResponse.ok) {\n                throw new Error('Failed to fetch usage data');\n            }\n\n            const usageData = await usageResponse.json();\n\n            // Fetch transaction data\n            const transactionResponse = await fetch(\n                `${supabaseUrl}/rest/v1/credit_transactions?${baseQuery}&transaction_type=eq.workflow_cost&select=*&order=created_at.desc`,\n                {\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json'\n                    }\n                }\n            );\n\n            if (!transactionResponse.ok) {\n                throw new Error('Failed to fetch transaction data');\n            }\n\n            const transactionData = await transactionResponse.json();\n\n            // Calculate summary metrics\n            const totalRuns = usageData.length;\n            const completedRuns = usageData.filter(u => u.execution_status === 'completed').length;\n            const failedRuns = usageData.filter(u => u.execution_status === 'failed').length;\n            const cancelledRuns = usageData.filter(u => u.execution_status === 'cancelled').length;\n            \n            const totalCost = transactionData.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);\n            const averageCost = totalRuns > 0 ? totalCost / totalRuns : 0;\n            \n            const completedUsage = usageData.filter(u => u.execution_status === 'completed');\n            const averageExecutionTime = completedUsage.length > 0 ?\n                completedUsage.reduce((sum, u) => sum + parseInt(u.execution_time_seconds || 0), 0) / completedUsage.length : 0;\n            \n            const totalResourceCost = usageData.reduce((sum, u) => sum + parseFloat(u.actual_cost || 0), 0);\n            const averageResourceCost = totalRuns > 0 ? totalResourceCost / totalRuns : 0;\n\n            // Success rate calculation\n            const successRate = totalRuns > 0 ? (completedRuns / totalRuns) * 100 : 0;\n\n            analyticsData.summary = {\n                period: {\n                    startDate: startIso,\n                    endDate: endIso,\n                    timeframe: timeframe\n                },\n                execution: {\n                    totalRuns: totalRuns,\n                    completedRuns: completedRuns,\n                    failedRuns: failedRuns,\n                    cancelledRuns: cancelledRuns,\n                    successRate: parseFloat(successRate.toFixed(2))\n                },\n                costs: {\n                    totalCreditsSpent: parseFloat(totalCost.toFixed(6)),\n                    averageCostPerRun: parseFloat(averageCost.toFixed(6)),\n                    totalResourceCost: parseFloat(totalResourceCost.toFixed(6)),\n                    averageResourceCost: parseFloat(averageResourceCost.toFixed(6))\n                },\n                performance: {\n                    averageExecutionTimeSeconds: parseFloat(averageExecutionTime.toFixed(2)),\n                    totalExecutionTimeSeconds: completedUsage.reduce((sum, u) => sum + parseInt(u.execution_time_seconds || 0), 0)\n                }\n            };\n\n            // Add workflow breakdown if requested\n            if (includeBreakdown) {\n                const workflowStats = {};\n                \n                usageData.forEach(usage => {\n                    const workflowId = usage.workflow_id;\n                    const workflowName = usage.workflow_name || 'Unknown';\n                    \n                    if (!workflowStats[workflowId]) {\n                        workflowStats[workflowId] = {\n                            workflowName: workflowName,\n                            totalRuns: 0,\n                            completedRuns: 0,\n                            failedRuns: 0,\n                            totalCost: 0,\n                            averageCost: 0,\n                            averageExecutionTime: 0,\n                            successRate: 0\n                        };\n                    }\n                    \n                    const stats = workflowStats[workflowId];\n                    stats.totalRuns++;\n                    \n                    if (usage.execution_status === 'completed') {\n                        stats.completedRuns++;\n                    } else if (usage.execution_status === 'failed') {\n                        stats.failedRuns++;\n                    }\n                    \n                    stats.totalCost += parseFloat(usage.actual_cost || 0);\n                });\n                \n                // Calculate averages and success rates\n                Object.keys(workflowStats).forEach(workflowId => {\n                    const stats = workflowStats[workflowId];\n                    stats.averageCost = stats.totalRuns > 0 ? stats.totalCost / stats.totalRuns : 0;\n                    stats.successRate = stats.totalRuns > 0 ? (stats.completedRuns / stats.totalRuns) * 100 : 0;\n                    \n                    // Format numbers\n                    stats.totalCost = parseFloat(stats.totalCost.toFixed(6));\n                    stats.averageCost = parseFloat(stats.averageCost.toFixed(6));\n                    stats.successRate = parseFloat(stats.successRate.toFixed(2));\n                });\n                \n                analyticsData.workflowBreakdown = workflowStats;\n            }\n\n            // Add detailed data if requested\n            if (reportType === 'detailed') {\n                analyticsData.detailedUsage = usageData.slice(0, 100); // Limit to latest 100 records\n                analyticsData.detailedTransactions = transactionData.slice(0, 100);\n            }\n        }\n\n        if (reportType === 'trends') {\n            // Generate time-series data grouped by the specified period\n            const trendsResponse = await fetch(\n                `${supabaseUrl}/rest/v1/usage_tracking?${baseQuery}&select=created_at,actual_cost,execution_status&order=created_at.asc`,\n                {\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json'\n                    }\n                }\n            );\n\n            if (trendsResponse.ok) {\n                const trendsData = await trendsResponse.json();\n                \n                // Group data by time period\n                const groupedData = {};\n                \n                trendsData.forEach(record => {\n                    const date = new Date(record.created_at);\n                    let groupKey;\n                    \n                    switch (groupBy) {\n                        case 'hour':\n                            groupKey = date.toISOString().slice(0, 13) + ':00:00.000Z';\n                            break;\n                        case 'day':\n                            groupKey = date.toISOString().slice(0, 10);\n                            break;\n                        case 'week':\n                            const weekStart = new Date(date);\n                            weekStart.setDate(date.getDate() - date.getDay());\n                            groupKey = weekStart.toISOString().slice(0, 10);\n                            break;\n                        case 'month':\n                            groupKey = date.toISOString().slice(0, 7);\n                            break;\n                        default:\n                            groupKey = date.toISOString().slice(0, 10);\n                    }\n                    \n                    if (!groupedData[groupKey]) {\n                        groupedData[groupKey] = {\n                            period: groupKey,\n                            totalRuns: 0,\n                            completedRuns: 0,\n                            failedRuns: 0,\n                            totalCost: 0,\n                            averageCost: 0\n                        };\n                    }\n                    \n                    const group = groupedData[groupKey];\n                    group.totalRuns++;\n                    group.totalCost += parseFloat(record.actual_cost || 0);\n                    \n                    if (record.execution_status === 'completed') {\n                        group.completedRuns++;\n                    } else if (record.execution_status === 'failed') {\n                        group.failedRuns++;\n                    }\n                });\n                \n                // Calculate averages and format data\n                const trendsSeries = Object.values(groupedData).map(group => ({\n                    ...group,\n                    averageCost: group.totalRuns > 0 ? parseFloat((group.totalCost / group.totalRuns).toFixed(6)) : 0,\n                    totalCost: parseFloat(group.totalCost.toFixed(6)),\n                    successRate: group.totalRuns > 0 ? parseFloat(((group.completedRuns / group.totalRuns) * 100).toFixed(2)) : 0\n                })).sort((a, b) => a.period.localeCompare(b.period));\n                \n                analyticsData.trends = trendsSeries;\n            }\n        }\n\n        // Return success response\n        const result = {\n            data: analyticsData,\n            meta: {\n                userId: userId,\n                reportType: reportType,\n                timeframe: timeframe,\n                groupBy: groupBy,\n                dateRange: {\n                    startDate: startIso,\n                    endDate: endIso\n                },\n                generatedAt: new Date().toISOString()\n            }\n        };\n\n        console.log('Usage analytics completed for user:', userId);\n\n        return new Response(JSON.stringify(result), {\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n        });\n\n    } catch (error) {\n        console.error('Usage analytics error:', error);\n\n        const errorResponse = {\n            error: {\n                code: 'USAGE_ANALYTICS_FAILED',\n                message: error.message,\n                timestamp: new Date().toISOString()\n            }\n        };\n\n        return new Response(JSON.stringify(errorResponse), {\n            status: 500,\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n        });\n    }\n});