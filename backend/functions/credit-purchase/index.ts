// Ooumph Coin Credit Purchase Edge Function\n// Handles credit purchases and account top-ups\n\nDeno.serve(async (req) => {\n    const corsHeaders = {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n        'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, PUT, DELETE, PATCH',\n        'Access-Control-Max-Age': '86400',\n        'Access-Control-Allow-Credentials': 'false'\n    };\n\n    if (req.method === 'OPTIONS') {\n        return new Response(null, { status: 200, headers: corsHeaders });\n    }\n\n    if (req.method !== 'POST') {\n        return new Response(\n            JSON.stringify({ error: { code: 'METHOD_NOT_ALLOWED', message: 'Only POST method is allowed' } }),\n            { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n        );\n    }\n\n    try {\n        const {\n            purchaseType, // 'manual', 'auto_recharge', 'bonus', 'promotional'\n            creditAmount,\n            fiatAmount,\n            currency = 'USD',\n            exchangeRate,\n            packageName,\n            packageTier,\n            paymentMethod,\n            paymentProcessor = 'stripe',\n            externalTransactionId,\n            promotionalCode,\n            bonusCredits = 0,\n            discountApplied = 0,\n            metadata = {}\n        } = await req.json();\n\n        console.log('Credit purchase request:', { purchaseType, creditAmount, fiatAmount });\n\n        // Validate required parameters\n        if (!purchaseType || !creditAmount) {\n            throw new Error('purchaseType and creditAmount are required');\n        }\n\n        if (creditAmount <= 0) {\n            throw new Error('creditAmount must be positive');\n        }\n\n        if (purchaseType === 'manual' && (!fiatAmount || !paymentMethod)) {\n            throw new Error('fiatAmount and paymentMethod are required for manual purchases');\n        }\n\n        // Get environment variables\n        const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\n        const supabaseUrl = Deno.env.get('SUPABASE_URL');\n\n        if (!serviceRoleKey || !supabaseUrl) {\n            throw new Error('Supabase configuration missing');\n        }\n\n        // Get user from auth header\n        const authHeader = req.headers.get('authorization');\n        if (!authHeader) {\n            throw new Error('Authorization header is required');\n        }\n\n        const token = authHeader.replace('Bearer ', '');\n        const userResponse = await fetch(`${supabaseUrl}/auth/v1/user`, {\n            headers: {\n                'Authorization': `Bearer ${token}`,\n                'apikey': serviceRoleKey\n            }\n        });\n\n        if (!userResponse.ok) {\n            throw new Error('Invalid or expired token');\n        }\n\n        const userData = await userResponse.json();\n        const userId = userData.id;\n\n        console.log('Credit purchase for user:', userId);\n\n        // Get or create user credits record\n        const creditsResponse = await fetch(\n            `${supabaseUrl}/rest/v1/user_credits?user_id=eq.${userId}&select=*`,\n            {\n                headers: {\n                    'Authorization': `Bearer ${serviceRoleKey}`,\n                    'apikey': serviceRoleKey,\n                    'Content-Type': 'application/json'\n                }\n            }\n        );\n\n        if (!creditsResponse.ok) {\n            throw new Error('Failed to fetch user credits');\n        }\n\n        const creditsData = await creditsResponse.json();\n        let userCredit;\n        \n        if (!creditsData || creditsData.length === 0) {\n            // Create new user credits record\n            const createResponse = await fetch(\n                `${supabaseUrl}/rest/v1/user_credits`,\n                {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json',\n                        'Prefer': 'return=representation'\n                    },\n                    body: JSON.stringify({\n                        user_id: userId,\n                        current_balance: 0,\n                        status: 'active'\n                    })\n                }\n            );\n\n            if (!createResponse.ok) {\n                throw new Error('Failed to create user credits account');\n            }\n\n            const newCreditsData = await createResponse.json();\n            userCredit = newCreditsData[0];\n        } else {\n            userCredit = creditsData[0];\n        }\n\n        const currentBalance = parseFloat(userCredit.current_balance);\n        const totalCreditsToAdd = parseFloat(creditAmount) + parseFloat(bonusCredits);\n        const newBalance = currentBalance + totalCreditsToAdd;\n        const newTotalEarned = parseFloat(userCredit.total_earned) + totalCreditsToAdd;\n        const newTotalPurchased = parseFloat(userCredit.total_purchased) + parseFloat(creditAmount);\n\n        // Generate transaction ID\n        const transactionId = crypto.randomUUID();\n        const billingTransactionId = `OC-${Date.now()}-${userId.slice(-8)}`;\n\n        // Update user credits balance\n        const updateCreditsResponse = await fetch(\n            `${supabaseUrl}/rest/v1/user_credits?user_id=eq.${userId}`,\n            {\n                method: 'PATCH',\n                headers: {\n                    'Authorization': `Bearer ${serviceRoleKey}`,\n                    'apikey': serviceRoleKey,\n                    'Content-Type': 'application/json',\n                    'Prefer': 'return=representation'\n                },\n                body: JSON.stringify({\n                    current_balance: newBalance,\n                    total_earned: newTotalEarned,\n                    total_purchased: newTotalPurchased,\n                    last_transaction_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                })\n            }\n        );\n\n        if (!updateCreditsResponse.ok) {\n            throw new Error('Failed to update user credits balance');\n        }\n\n        console.log('Credits balance updated successfully');\n\n        // Record the main purchase transaction\n        const mainTransactionData = {\n            user_id: userId,\n            transaction_type: 'purchase',\n            amount: parseFloat(creditAmount),\n            balance_before: currentBalance,\n            balance_after: currentBalance + parseFloat(creditAmount),\n            description: `Credit purchase: ${packageName || `${creditAmount} ooumph coins`}`,\n            reference_type: 'credit_purchase',\n            reference_id: transactionId,\n            payment_method: paymentMethod || 'unknown',\n            external_transaction_id: externalTransactionId,\n            status: 'completed',\n            processed_by: 'credit-purchase-function',\n            metadata: {\n                purchase_type: purchaseType,\n                package_name: packageName,\n                package_tier: packageTier,\n                promotional_code: promotionalCode,\n                fiat_amount: fiatAmount,\n                currency: currency,\n                exchange_rate: exchangeRate,\n                discount_applied: discountApplied,\n                ...metadata\n            }\n        };\n\n        const transactionResponse = await fetch(\n            `${supabaseUrl}/rest/v1/credit_transactions`,\n            {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${serviceRoleKey}`,\n                    'apikey': serviceRoleKey,\n                    'Content-Type': 'application/json',\n                    'Prefer': 'return=representation'\n                },\n                body: JSON.stringify(mainTransactionData)\n            }\n        );\n\n        if (!transactionResponse.ok) {\n            console.error('Failed to record purchase transaction');\n            throw new Error('Failed to record purchase transaction');\n        }\n\n        const transactionResult = await transactionResponse.json();\n        console.log('Purchase transaction recorded successfully');\n\n        // Record bonus credits transaction if applicable\n        let bonusTransactionResult = null;\n        if (parseFloat(bonusCredits) > 0) {\n            const bonusTransactionData = {\n                user_id: userId,\n                transaction_type: 'bonus',\n                amount: parseFloat(bonusCredits),\n                balance_before: currentBalance + parseFloat(creditAmount),\n                balance_after: newBalance,\n                description: `Bonus credits: ${bonusCredits} ooumph coins`,\n                reference_type: 'credit_purchase',\n                reference_id: transactionId,\n                status: 'completed',\n                processed_by: 'credit-purchase-function',\n                metadata: {\n                    bonus_type: 'purchase_bonus',\n                    main_transaction_id: transactionResult[0]?.id,\n                    package_name: packageName,\n                    promotional_code: promotionalCode\n                }\n            };\n\n            const bonusTransactionResponse = await fetch(\n                `${supabaseUrl}/rest/v1/credit_transactions`,\n                {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json',\n                        'Prefer': 'return=representation'\n                    },\n                    body: JSON.stringify(bonusTransactionData)\n                }\n            );\n\n            if (bonusTransactionResponse.ok) {\n                bonusTransactionResult = await bonusTransactionResponse.json();\n                console.log('Bonus transaction recorded successfully');\n            }\n        }\n\n        // Record in billing history\n        const billingHistoryData = {\n            user_id: userId,\n            billing_transaction_id: billingTransactionId,\n            external_transaction_id: externalTransactionId,\n            transaction_type: 'credit_purchase',\n            currency_code: currency,\n            fiat_amount: parseFloat(fiatAmount || 0),\n            credit_amount: parseFloat(creditAmount),\n            exchange_rate: parseFloat(exchangeRate || 1),\n            package_name: packageName,\n            package_tier: packageTier,\n            bonus_credits: parseFloat(bonusCredits),\n            discount_applied: parseFloat(discountApplied),\n            promotional_code: promotionalCode,\n            payment_method: paymentMethod || 'unknown',\n            payment_processor: paymentProcessor,\n            status: 'completed',\n            transaction_date: new Date().toISOString(),\n            processed_at: new Date().toISOString(),\n            metadata: {\n                credit_transaction_id: transactionResult[0]?.id,\n                bonus_transaction_id: bonusTransactionResult?.[0]?.id,\n                purchase_type: purchaseType,\n                ...metadata\n            },\n            processed_by: 'credit-purchase-function'\n        };\n\n        const billingResponse = await fetch(\n            `${supabaseUrl}/rest/v1/billing_history`,\n            {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Bearer ${serviceRoleKey}`,\n                    'apikey': serviceRoleKey,\n                    'Content-Type': 'application/json',\n                    'Prefer': 'return=representation'\n                },\n                body: JSON.stringify(billingHistoryData)\n            }\n        );\n\n        let billingResult = null;\n        if (billingResponse.ok) {\n            billingResult = await billingResponse.json();\n            console.log('Billing history recorded successfully');\n        } else {\n            console.warn('Failed to record billing history');\n        }\n\n        // Check if auto-recharge threshold was triggered and should be updated\n        if (purchaseType === 'auto_recharge' && userCredit.auto_recharge_enabled) {\n            // Update last auto-recharge timestamp in preferences\n            const updatedPreferences = {\n                ...userCredit.preferences,\n                last_auto_recharge: new Date().toISOString(),\n                auto_recharge_count: (userCredit.preferences?.auto_recharge_count || 0) + 1\n            };\n\n            await fetch(\n                `${supabaseUrl}/rest/v1/user_credits?user_id=eq.${userId}`,\n                {\n                    method: 'PATCH',\n                    headers: {\n                        'Authorization': `Bearer ${serviceRoleKey}`,\n                        'apikey': serviceRoleKey,\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        preferences: updatedPreferences\n                    })\n                }\n            );\n        }\n\n        // Return success response\n        const result = {\n            data: {\n                success: true,\n                transactionId: transactionResult[0]?.id,\n                billingTransactionId: billingTransactionId,\n                creditsAdded: totalCreditsToAdd,\n                creditsPurchased: parseFloat(creditAmount),\n                bonusCredits: parseFloat(bonusCredits),\n                previousBalance: currentBalance,\n                newBalance: newBalance,\n                fiatAmount: parseFloat(fiatAmount || 0),\n                currency: currency,\n                exchangeRate: parseFloat(exchangeRate || 1),\n                purchaseType: purchaseType,\n                packageName: packageName,\n                packageTier: packageTier,\n                timestamp: new Date().toISOString()\n            }\n        };\n\n        console.log('Credit purchase completed successfully');\n\n        return new Response(JSON.stringify(result), {\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n        });\n\n    } catch (error) {\n        console.error('Credit purchase error:', error);\n\n        const errorResponse = {\n            error: {\n                code: 'CREDIT_PURCHASE_FAILED',\n                message: error.message,\n                timestamp: new Date().toISOString()\n            }\n        };\n\n        return new Response(JSON.stringify(errorResponse), {\n            status: 500,\n            headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n        });\n    }\n});